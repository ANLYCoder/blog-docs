> 本文来自阿里巴巴中间件，有改动
>
> 原文链接 : [分布式事务 GTS 的价值和原理浅析](https://mp.weixin.qq.com/s/po8gWGrvU63hbDphzV10Iw)

## 前言

随着企业的发展，企业业务架构面临数据、服务的分布化，几乎无可避免地要遇到分布式架构带来的数据一致性问题。



GTS(全局事务服务，Global Transaction Service) 开创性地把分布式事务问题从业务中剥离出来，作为一个独立的技术切面来单独管理，以服务的形式给构建在云上的应用提供简单、易用、高效的分布式事务解决方案。



GTS 给业务应用带来的价值体现在以下几个方面：



- 架构复杂度降低：分布式事务这个 切面 的技术问题，全部 收敛 到 GTS 提供的服务来解决。
- 设计和开发成本减轻：业务逻辑的设计和开发，完全不需要针对是否涉及分布式事务而做任何额外的事情，对业务 0 侵入 。
- 项目交付、迭代速度加快：归因于上述两点，项目得以很快交付和迭代。GTS 赋予业务应用 快速试错 的能力，在这个商业机会瞬息万变的时代，显得尤为重要。



设想一个典型的云原生企业应用的成长路径：



![img](http://img.blog.ztgreat.cn/document/transaction/1575277132759.png)



- 1.0：单体应用，快速上线，这个时候完全不涉及分布式事务。
- 2.0：单个数据库无法支撑，数据分布到多个数据库，产生分布式事务问题。
- 3.0：微服务化，进一步产生跨服务的分布式事务。
- 4.0：跨应用的整合，成为 SaaS 或 FaaS 的平台，在更大的范围，产生分布式事务问题。



基于 GTS 提供的分布式事务服务，企业发展各阶段产生的不同场景下的数据一致性问题，可以得到一站式的解决。这使得业务可以平滑自然地，像搭积木一样成长起来。



从上面示例可以看到：GTS 实际上是把分布式事务（或者说分布式场景下的数据一致性）能力，作为一种 云原生 的服务，提供给生长在云上的应用，让分布式事务不再成为业务要面临的一个令人头疼的问题，而成为一种可以弹性伸缩，按需取用的服务能力。



## CAP理论

CAP理论说的是：在一个分布式系统中，最多只能满足C、A、P中的两个需求。

CAP的含义：

- C：Consistency 一致性同一数据的多个副本是否实时相同。
- A：Availability 可用性可用性：一定时间内 & 系统返回一个明确的结果 则称为该系统可用。
- P：Partition tolerance 分区容错性将同一服务分布在多个系统中，从而保证某一个系统宕机，仍然有其他系统提供相同的服务。

CAP理论告诉我们，在分布式系统中，C、A、P三个条件中我们最多只能选择两个。那么问题来了，究竟选择哪两个条件较为合适呢？

对于一个业务系统来说，可用性和分区容错性是必须要满足的两个条件，并且这两者是相辅相成的。业务系统之所以使用分布式系统，主要原因有两个：

- 提升整体性能当业务量猛增，单个服务器已经无法满足我们的业务需求的时候，就需要使用分布式系统，使用多个节点提供相同的功能，从而整体上提升系统的性能，这就是使用分布式系统的第一个原因。
- 实现分区容错性单一节点 或 多个节点处于相同的网络环境下，那么会存在一定的风险，万一该机房断电、该地区发生自然灾害，那么业务系统就全面瘫痪了。为了防止这一问题，采用分布式系统，将多个子系统分布在不同的地域、不同的机房中，从而保证系统高可用性。

这说明分区容错性是分布式系统的根本，如果分区容错性不能满足，那使用分布式系统将失去意义。

此外，可用性对业务系统也尤为重要。在大谈用户体验的今天，如果业务系统时常出现“系统异常”、响应时间过长等情况，这使得用户对系统的好感度大打折扣，在互联网行业竞争激烈的今天，相同领域的竞争者不甚枚举，系统的间歇性不可用会立马导致用户流向竞争对手。因此，我们只能通过牺牲一致性来换取系统的**可用性**和**分区容错性**。这也就是下面要介绍的BASE理论。

## BASE理论

CAP理论告诉我们一个悲惨但不得不接受的事实——我们只能在C、A、P中选择两个条件。而对于业务系统而言，我们往往选择牺牲一致性来换取系统的可用性和分区容错性。不过这里要指出的是，所谓的“牺牲一致性”并不是完全放弃数据一致性，而是牺牲**强一致性**换取**弱一致性**。下面来介绍下BASE理论。

- BA：Basic Available 基本可用

- - 整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。只不过“基本可用”和“高可用”的区别是：

- - - “一定时间”可以适当延长当举行大促时，响应时间可以适当延长
    - 给部分用户返回一个降级页面给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。

- S：Soft State：柔性状态同一数据的不同副本的状态，可以不需要实时一致。
- E：Eventual Consisstency：最终一致性同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。

## 分布式事务协议

下面介绍几种实现分布式事务的协议。

### 两阶段提交协议 2PC

分布式系统的一个难点是如何保证架构下多个节点在进行事务性操作的时候保持一致性。为实现这个目的，二阶段提交算法的成立基于以下假设：

- 该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。且节点之间可以进行网络通信。
- 所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。
- 所有节点不会永久性损坏，即使损坏后仍然可以恢复。

**1. 第一阶段（投票阶段）：**

1. 协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。
2. 参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）
3. 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个"同意"消息；如果参与者节点的事务操作实际执行失败，则它返回一个"中止"消息。

**2. 第二阶段（提交执行阶段）：**

当协调者节点从所有参与者节点获得的相应消息都为"同意"时：

1. 协调者节点向所有参与者节点发出"正式提交(commit)"的请求。
2. 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送"完成"消息。
4. 协调者节点受到所有参与者节点反馈的"完成"消息后，完成事务。

如果任一参与者节点在第一阶段返回的响应消息为"中止"，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：

1. 协调者节点向所有参与者节点发出"回滚操作(rollback)"的请求。
2. 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送"回滚完成"消息。
4. 协调者节点受到所有参与者节点反馈的"回滚完成"消息后，取消事务。

不管最后结果如何，第二阶段都会结束当前事务。

二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：

1. 执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
2. 参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。（没有多少容错机制）
3. 协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。（这个可以依赖后面要讲的Paxos协议实现HA）
4. 二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

为此，Dale Skeen和Michael Stonebraker在“A Formal Model of Crash Recovery in a Distributed System”中提出了三阶段提交协议（3PC）。

### 三阶段提交协议 3PC

与两阶段提交不同的是，三阶段提交有两个改动点。

- 引入超时机制。同时在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。

**1. CanCommit阶段**

3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。

1. 事务询问协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
2. 响应反馈参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No

**2. PreCommit阶段**

协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。

1. 发送预提交请求协调者向参与者发送PreCommit请求，并进入Prepared阶段。
2. 事务预提交参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
3. 响应反馈如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。

1. 发送中断请求协调者向所有参与者发送abort请求。
2. 中断事务参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。

**3. doCommit阶段**该阶段进行真正的事务提交，也可以分为以下两种情况。

该阶段进行真正的事务提交，也可以分为以下两种情况。

**3.1 执行提交**

1. 发送提交请求协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
2. 事务提交参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
3. 响应反馈事务提交完之后，向协调者发送Ack响应。
4. 完成事务协调者接收到所有参与者的ack响应之后，完成事务。

**3.2 中断事务**协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。

1. 发送中断请求协调者向所有参与者发送abort请求
2. 事务回滚参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
3. 反馈结果参与者完成事务回滚之后，向协调者发送ACK消息
4. 中断事务协调者接收到参与者反馈的ACK消息之后，执行事务的中断。



## **GTS 的原理和创新**



下面，从几个方面来大体介绍 GTS 的原理和创新。



首先，GTS 把分布式事务定义为由若干本地事务（分支）组成的全局事务。被全局事务管理的全部分支，将在协调器的协调下，保证一起成功或一起回滚。



![15752771327](http://img.blog.ztgreat.cn/document/transaction/1575277132711.png)



其次，GTS 定义了一个事务模型，把整个全局事务过程模型化为 TM、RM、TC 三个组件之间协作的机制。



- Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。
- Transaction Manager (TM)：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。
- Resource Manager (RM)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。



![1575277132788](http://img.blog.ztgreat.cn/document/transaction/1575277132788.png)



一个典型的分布式事务过程：



1. TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。
2. XID 在微服务调用链路的上下文中传播。
3. RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖。
4. TM 向 TC 发起针对 XID 的全局提交或回滚决议。
5. TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。



第三，GTS 创新地基于 SQL 解析实现对业务无侵入的自动补偿回滚机制。这种机制，GTS 将其命名为 Auto Transaction (AT) 模式。基本工作原理如下：



GTS 把全局事务分为两个阶段：执行阶段 和 完成阶段 。



**执行阶段：**



GTS 的 JDBC 数据源代理通过对业务 SQL 的解析，把业务数据在更新前后的数据镜像组织成回滚日志，利用 本地事务 的 ACID 特性，将业务数据的更新和回滚日志的写入在同一个 本地事务 中提交。



这样，可以保证：任何提交的业务数据的更新一定有相应的回滚日志存在。



![1575277132815](http://img.blog.ztgreat.cn/document/transaction/1575277132815.png)



基于这样的机制，分支的本地事务便可以在全局事务的 执行阶段 提交，马上释放本地事务锁定的资源。



**完成阶段：**



- 如果 TM 发出的决议是全局提交，此时分支事务此时已经完成提交，不需要同步协调处理（只需要异步清理回滚日志），完成阶段 可以非常快速地完成。

![1575277132772](http://img.blog.ztgreat.cn/document/transaction/1575277132772.png)





- 如果 TM 发出的决议是全局回滚，RM 收到协调器发来的回滚请求，通过 XID 和 Branch ID 找到相应的回滚日志记录，通过回滚记录生成反向的更新 SQL 并执行，以完成分支的回滚。

![1575277132783](http://img.blog.ztgreat.cn/document/transaction/1575277132783.png)



最后，GTS 通过事务协调器集群以及对业务应用节点的容错，实现一个拒绝单点故障的高可用服务。

![1575277132787](http://img.blog.ztgreat.cn/document/transaction/1575277132787.png)





一方面，GTS 服务集群机制，保障任意服务节点宕机，可以其他节点无缝接管。

另一方面，应用任意节点的宕机，相应事务分支的请求也会路由到连接相同数据库的其他节点上，不影响全局事务的完整执行。





## **GTS 的事务模式**



截止目前，还没有任何一种分布式事务的技术方案，可以满足所有场景的问题。GTS 的 AT 模式适用于绝大部分常见场景，但仍有一些场景更适合于使用业界其他的分布式事务解决方案。



当前分布式应用层面，最具代表性的事务模式有 4 种，分别是 AT、TCC、Saga 和 XA，这些模式各有优缺点和适用的场景。



**AT 模式**



优势：业务无侵入；轻量，不依赖数据库的高级特性；回滚较少的场景性能高。

劣势：隔离性不高，目前只能支持到接近 读已提交 的程度，更高的隔离级别，实现成本将非常高。



**TCC 模式**

TCC即为Try Confirm Cancel，它属于补偿型分布式事务。顾名思义，TCC实现分布式事务一共有三个步骤：

- Try：尝试待执行的业务

- - 这个过程并未执行业务，只是完成所有业务的一致性检查，并预留好执行所需的全部资源

- Confirm：执行业务

- - 这个过程真正开始执行业务，由于Try阶段已经完成了一致性检查，因此本过程直接执行，而不做任何检查。并且在执行的过程中，会使用到Try阶段预留的业务资源。

- Cancel：取消执行的业务

- - 若业务执行失败，则进入Cancel阶段，它会释放所有占用的业务资源，并回滚Confirm阶段执行的操作。

优势：适用场景广泛；隔离性和性能都可以做极致优化。

劣势：业务侵入性非常高。



**Saga 模式**



优势：适用于长事务场景。

劣势：有一定业务侵入性；隔离性差。



**XA 模式**



优势：业务无侵入；隔离性好。

劣势：较重的依赖；阻塞协议。



上述事务模式，AT 和 TCC 已经在 GTS 中提供了支持（TCC 模式在 GTS 中当前的名字是 MT），Saga 和 XA 也在研发过程中。

GTS 会把各类解决方案融合到 GTS 提供的云服务框架中，为云原生应用提供一站式的分布式事务服务。



## 总结

GTS 自从 2014 年诞生于阿里巴巴中间件的 5 年来，从支撑集团内第一个业务方开始，经历了从内部到云产品化，从封闭到开源，从单一模式到兼容并蓄和标准化，一直坚定地走在分布式事务领域的最前沿。



GTS 的目标是成为云原生时代，分布式事务的全面解决方案。任何分布式事务需求，在 GTS 上都能找到满意的答案。